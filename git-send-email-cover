The paravirtualized CR pinning patchset is a strengthened version of
existing control register pinning for paravritualized guests. It
protects KVM guests from ROP (and the like) based attacks which attempt to
disable key security features. Virtualized Linux guests such as Kata Containers,
AWS Lambda, and Chromos Termina will get this protection enabled by default when
they update their kernel / configs. Using virtualization allows us to provide a
stronger version of a proven exploit mitigation technique we already have
implemented natively.

We've patched KVM to create 6 new KVM specific MSRs used to query which
bits may be pinned, and to set which bits are pinned high or low in
control registers 0 and 4. Linux guest support was added so that
guests will be able to take advantage of this strengthened protection by
default.

Hibernation and suspend to ram were enabled by updating the location
where bits in control register 4 were saved to and restored from. The
work also includes minor patches for QEMU to ensure reboot works by
clearing the added MSRs and exposing the new CPUID feature bit. There is
one SMM related selftest added in this patchset and another patch for
kvm-unit-tests that will be sent separately.

Thank you to Dave who reviewed v1. Sean and Drew who reviewed v2, to Boris,
Paolo, Andy, and Liran who reviewed v1, and to Sean, Dave, Kristen, and Rick
who've provided feedback throughout.

Here are the previous versions of this patchset for reference

PATCH v1: https://lkml.org/lkml/2020/6/17/921
RFC v2: https://lkml.org/lkml/2020/2/18/1162
RFC v1: https://lkml.org/lkml/2019/12/24/380



=== High level overview of the changes ===

- A CPUID feature bit as well as MSRs were added to KVM. Guests can use
  the CPUID feature bit to determine if MSRs are available. Reading the
  first 2 MSRs returns the bits which are allowed to be pinned for CR0/4
  respectively. Allowed bits to pin default to the same set we pin natively.
  Host VMM may override which bits are allowed to be pinned. The next 4 MSRs are
  writeable and allow the guest and host userspace to set which bits are pinned
  low or pinned high for CR0/4.

- Hibernation and suspend-to-RAM are supported. This was done by
  updating mmu_cr4_features on feature identification of the boot CPU.
  As such, mmu_cr4_features is no longer read only after init.

- CPU hotplug is supported. Pinning is per vCPU. When running as a guest
  pinning is requested after CPU identification for non-boot CPUs. The
  boot CPU requests pinning a directly after existing pinning is setup.

- Nested virtualization is supported. SVM / VMX restore pinned bits on
  VM-Exit if they had been unset in the host VMCB / VMCS.

- As suggested by Sean, unpinning of pinned bits on return from SMM due
  to modification of SMRAM will cause an unhandleable emulation fault
  resulting in termination of the guest.

- kexec support is still pending, since the plan is a bit long it's been
  moved to the end of the cover letter. It talks about the decision to
  make a command line parameter, why we opt in to pinning (and
  effectively out of kexec). Being that those changes wouldn't be
  localized to KVM (and this patchset is on top of kvm/next).


=== Testing ===

- A patch will be sent immediately following this patchset for kvm-unit-tests
  with the unit tests for general functionality. selftests are included for SMM
  specific functionality.

- This has been tested to work with

  - reboot

  - kexec

  - hibernate / suspend to RAM

  - SMM

  - CPU hotplug


=== Changes since PATCH v1 ===

- Andy and Dave's comments on the allowed set of bits and how we shouldn't
  restrict the allowed set

  - The allowed bits default to the set which we pin natively. They can be
    modified by the host VMM should there be a usecase for that.

- Dave's comments

  - Added disable_kexec command line option

  - Added disable_pv_cr_pin command line option

  - Removed pv_cr_pin command line option


=== kexec ===

There has been a lot of discussion around kexec, which is now supported in PATCH
v2. This section covers what kexec support looks like to end users.

Liran's proposed solution of a flag within the ELF which allows us to identify
which kernels have support has been implemented as an addition to kernel_info.S

We now have the following cases

K0 - The running kernel
K1 - Kernel we are going to execute from K0

NS - Not Supported
NE - Supported, Not enabled (via disable_pv_cr_pin or lack of feature flag)
SE - Supported, Enabled

          +----------------------+----------------------+----------------------+
          |                      |                      |                      |
          |        K1 - NS       |       K1 - NE        |       K1 - SE        |
          |                      |                      |                      |
+---------+----------------------+----------------------+----------------------+
|         |                      |                      |                      |
| K0 - NS |         NOP          |         NOP          |       Turn On        |
|         |                      |                      |                      |
+---------+----------------------+----------------------+----------------------+
|         |                      |                      |                      |
| K0 - NE |         NOP          |         NOP          |       Turn On        |
|         |                      |                      |                      |
+---------+----------------------+----------------------+----------------------+
|         |                      |                      |                      |
| K0 - SE |   kexec checks (1)   |       Works (2)      |       Keep On        |
|         |                      |                      |                      |
+---------+----------------------+----------------------+----------------------+


1. When control register pinning is enabled the kexec_load system call is
   disabled (returns -EINVAL). All kexec's must go through kexec_file.

   kexec_file has facilities for checking if K1 can be launched without error.
   kexec-tools will be patched to require (or default to) using kexec_file if
   pinning is enabled in K0.

- Kernel running without pinning enabled kexecs kernel with pinning.

  - Loaded kernel has kexec (or is not disabled via disable_kexec)

    - Do not enable pinning

  - Loaded kernel lacks kexec (or is disabled via disable_kexec)

    - Enable pinning

- Kernel running with pinning enabled kexecs kernel with pinning (as
  identified by ELF addition).

  - Okay

- Kernel running with pinning enabled kexecs kernel without pinning
  (as identified by lack of ELF addition).

  - User is presented with an error saying that they may not kexec
    a kernel without pinning support.



=== Description of changes and rational ===

Paravirtualized Control Register pinning is a strengthened version of
existing protections on the Write Protect, Supervisor Mode Execution /
Access Protection, and User-Mode Instruction Prevention bits. The
existing protections prevent native_write_cr*() functions from writing
values which disable those bits. This patchset prevents any guest
writes to control registers from disabling pinned bits, not just writes
from native_write_cr*(). This stops attackers within the guest from
using ROP to disable protection bits.

https://web.archive.org/web/20171029060939/http://www.blackbunny.io/linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric/

The protection is implemented by adding MSRs to KVM which contain the
bits that are allowed to be pinned, and the bits which are pinned. The
guest or userspace can enable bit pinning by reading MSRs to check
which bits are allowed to be pinned, and then writing MSRs to set which
bits they want pinned.

Other hypervisors such as HyperV have implemented similar protections
for Control Registers and MSRs; which security researchers have found
effective.

https://www.abatchy.com/2018/01/kernel-exploitation-4

We add a CR pin feature bit to the KVM cpuid, MSRs which guests use to identify
which bits they may request be pinned, and CR pinned low/high MSRs which contain
the pinned bits. Host VMM may modify which bits are allowed to be pinned. Guests
can request that KVM pin bits within control register 0 or 4 via the CR pinned
MSRs. Writes to the MSRs fail if they include bits that aren't allowed to be
pinned. Host userspace may clear or modify pinned bits at any time. Once pinned
bits are set, the guest may pin more allowed bits, but may never clear pinned
bits.

In the event that the guest vCPU attempts to disable any of the pinned
bits, the vCPU that issued the write is sent a general protection
fault, and the register is left unchanged.

When running with KVM guest support and paravirtualized CR pinning
enabled, paravirtualized and existing pinning are setup at the same
point on the boot CPU. Non-boot CPUs setup pinning upon identification.

Pinning is not active when running in SMM. Entering SMM disables pinned
bits. Writes to control registers within SMM would therefore trigger
general protection faults if pinning was enforced. Upon exit from SMM,
SMRAM is modified to ensure the values of CR0/4 that will be restored
contain the correct values for pinned bits. CR0/4 values are then
restored from SMRAM as usual.

When running with nested virtualization, should pinned bits be cleared
from host VMCS / VMCB, on VM-Exit, they will be silently restored.

Should userspace expose the CR pining CPUID feature bit, it must zero
CR pinned MSRs on reboot. If it does not, it runs the risk of having
the guest enable pinning and subsequently cause general protection
faults on next boot due to early boot code setting control registers to
values which do not contain the pinned bits.

Hibernation to disk and suspend-to-RAM are supported. identify_cpu() was
updated to ensure SMEP/SMAP/UMIP are present in mmu_cr4_features. This
is necessary to ensure protections stay active during hibernation image
restoration.

Guests using the kexec system call currently do not support
paravirtualized control register pinning. This is due to early boot
code writing known good values to control registers, these values do
not contain the protected bits. This is due to CPU feature
identification being done at a later time, when the kernel properly
checks if it can enable protections.

Paravirtualized control register pinning will be enabled by default if
available and kexec support is either not present or disabled via
disable_kexec. Disabling kexec via it's sysctl will not result in the
enabling of paravirtualized pinning, do to the setting of sysctl's
happening after the check for pinning.

Should the user find that paravirtualized pinning causes issues for
them, it can be disabled using the new disable_pv_cr_pin command line
option.

When we fix kexec, we will still need a way for a kernel with support to
know if the kernel it is attempting to load has support. If a kernel
with this enabled attempts to kexec a kernel where this is not
supported, it would trigger a fault almost immediately.

Liran suggested adding a section to the built image acting as a flag to
signify support for being kexec'd by a kernel with pinning enabled.
Should that approach be implemented, any kernel without support for
pinning would no longer be able to be kexec'd by a kernel running with
pinning enabled. Should the user wish to kexec kernels lacking pinning
support, they would have to disable paravirtualized pinning.

Security conscious kernel configurations disable kexec already, per
KSPP guidelines. Projects such as Kata Containers, AWS Lambda, ChromeOS
Termina, and others using KVM to virtualize Linux will benefit from
this protection without the need to specify pv_cr_pin on the command
line.

Pinning of sensitive CR bits has already been implemented to protect
against exploits directly calling native_write_cr*(). The current
protection cannot stop ROP attacks which jump directly to a MOV CR
instruction. Guests running with paravirtualized CR pinning are now
protected against the use of ROP to disable CR bits. The same bits that
are being pinned natively may be pinned via the CR pinned MSRs. These
bits are WP in CR0, and SMEP, SMAP, and UMIP in CR4.

Future patches could implement similar MSRs to protect bits in MSRs.
The NXE bit of the EFER MSR is a prime candidate.


Thanks,
John
