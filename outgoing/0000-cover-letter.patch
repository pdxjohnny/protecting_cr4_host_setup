From 7181b2f3502c58fcd725f8d4d57c74ba44a6427e Mon Sep 17 00:00:00 2001
From: John Andersen <john.s.andersen@intel.com>
Date: Mon, 25 Nov 2019 14:48:03 -0500
Subject: [RFC 0/2] Implement CR Pinning via Hardening Hypercall
In-Reply-To: 

Add a kernel hardening hypercall to KVM. Allow guests to request
enabling of protections. Implement CR0 and CR4 bit pinning protections.
A guest may request bits be added (but never removed) from a bit mask
for each register. CR pinning is per kvm, rather than per vcpu. Should
the guest attempt to disable any of the pinned bits which are also
currently set in the control register, send that guest a general
protection fault, and leave the register unchanged. On SMP bringup of
non-boot CPUs control registers will not yet have bits which are pinned
set, only send general protection faults when a write to the control
register would unset a bit which is pinned. When syncing control
registers with userspace if userspace clears bits that are pinned, unpin
those bits. QEMU zeros control registers on reboot, if pinned bits are
not cleared, initial writes to control registers by the rebooted guest
cause general protection faults.

Pinning of sensitive CR bits has already been implemented to protect
against exploits directly calling native_write_crX. The current
protection cannot stop ROP attacks which jump directly to a MOV CR
instruction. Guests running with hypervisor based CR pinning are now
protected against the use of ROP to disable CR bits. The same bits that
are being pinned in the current implementation are pinned via the
hypervisor. These bits are WP in CR0, and SMEP, SMAP, and UMIP in CR4.

The practice of protecting CRs and MSRs of guests is a known method
implemented by other hypervisors such as HyperV:

https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/vbs-resource-protections

Future use of the hardening hypercall could include protecting the NXE
bit of the EFER MSR.

Guests using the kexec system call currently do not support hypervisor
based control register pinning. This is due to early boot zeroing
protected registers.

John Andersen (2):
  KVM: X86: Add setters for guest owned CR bits
  KVM: X86: Add kernel hardening hypercall

 Documentation/virt/kvm/hypercalls.txt | 29 ++++++++++++
 arch/x86/Kconfig                      | 10 ++++
 arch/x86/include/asm/kvm_host.h       |  4 ++
 arch/x86/include/uapi/asm/kvm_para.h  |  5 ++
 arch/x86/kernel/cpu/common.c          | 18 +++++++
 arch/x86/kvm/cpuid.c                  |  3 +-
 arch/x86/kvm/svm.c                    | 40 +++++++++++++++-
 arch/x86/kvm/vmx/nested.c             |  8 ++--
 arch/x86/kvm/vmx/vmx.c                | 40 +++++++++-------
 arch/x86/kvm/vmx/vmx.h                |  8 ++++
 arch/x86/kvm/x86.c                    | 67 +++++++++++++++++++++++++++
 include/linux/kvm_host.h              |  5 ++
 include/uapi/linux/kvm_para.h         |  1 +
 13 files changed, 215 insertions(+), 23 deletions(-)

-- 
2.21.0

