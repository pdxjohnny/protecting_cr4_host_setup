From d733aedf0437e678f750bc4451c66d5c9c02746b Mon Sep 17 00:00:00 2001
From: John Andersen <john.s.andersen@intel.com>
Date: Mon, 14 Sep 2020 10:59:32 -0700
Subject: [PATCH 9/9] X86: kexec: PV CR pinning support check

Add the kernel_info structure to the userspace API headers.
The structure currently only includes the fixed length fields, as no
variable length fields currently exist.

Update kernel_info.S to include the string "PVCR" at the end of the
fixed length data. Include this new member within the newly added
kernel_info structure.

When paravirtualized control register pinning is enabled
bzImage64_probe() will check that the bzImage contains the kernel_info
structure and that the kernel we're attempting to load supports PV CR
pinning by looking for the string "PVCR" within the fixed length data.
If the image we're loading does not support PV CR pinning and it's
currently enabled -ENOEXEC is returned.

Preform the support check within bzImage64_probe() by calculating the
start of the kernel per guidelines in Documentation/x86/boot.rst. Take
the number of setup sectors plus 1 and multiply it by 512 (shift left
9). Use the start of the kernel and the kernel info offset from the real
mode kernel header to find the kernel_info structure. Check if the magic
bytes "PVCR" match up with the pv_cr_pinning_magic field of the
kernel_info structure.

Implement arch_kexec_load_check() for X86. Make the implementation
return -EINVAL if paravritaulized control register pinning is enabled.
We block off the kexec_load path with -EINVAL thereby forceing users to
use the kexec_file system call which preforms the check for PV CR
pinning support.

kexec-tools needs updating to require the use of the kexec_file syscall
if paravirtualized control register pinning is enabled. By adding these
checks users will not end up with a situation where they kexec a kernel
without support for PV CR pinning from a kernel with it enabled. It's
important we help users avoid this case because their system would
crash since older kernel did not keep pinned protections enabled through
kexec.

https://github.com/pdxjohnny/kexec-tools/commit/dde3dea426b7bd32f42d5c60e18dd48878aa7ed5

Signed-off-by: John Andersen <john.s.andersen@intel.com>
---
 arch/x86/boot/compressed/kernel_info.S |  3 ++
 arch/x86/include/uapi/asm/bootparam.h  |  8 ++++++
 arch/x86/kernel/kexec-bzimage64.c      | 38 +++++++++++++++++++++++++-
 arch/x86/kernel/machine_kexec_64.c     | 16 +++++++++++
 4 files changed, 64 insertions(+), 1 deletion(-)

diff --git a/arch/x86/boot/compressed/kernel_info.S b/arch/x86/boot/compressed/kernel_info.S
index f818ee8fba38..da3909d3281f 100644
--- a/arch/x86/boot/compressed/kernel_info.S
+++ b/arch/x86/boot/compressed/kernel_info.S
@@ -17,6 +17,9 @@ kernel_info:
 	/* Maximal allowed type for setup_data and setup_indirect structs. */
 	.long	SETUP_TYPE_MAX
 
+	/* Indicate support for paravritualized control register pinning */
+	.ascii	"PVCR"
+
 kernel_info_var_len_data:
 	/* Empty for time being... */
 kernel_info_end:
diff --git a/arch/x86/include/uapi/asm/bootparam.h b/arch/x86/include/uapi/asm/bootparam.h
index 600a141c8805..3b6a065d7af8 100644
--- a/arch/x86/include/uapi/asm/bootparam.h
+++ b/arch/x86/include/uapi/asm/bootparam.h
@@ -104,6 +104,14 @@ struct setup_header {
 	__u32	kernel_info_offset;
 } __attribute__((packed));
 
+struct kernel_info {
+	__u32	header;
+	__u32	size;
+	__u32	size_total;
+	__u32	setup_type_max;
+	__u32	pv_cr_pinning_magic;
+} __attribute__((packed));
+
 struct sys_desc_table {
 	__u16 length;
 	__u8  table[14];
diff --git a/arch/x86/kernel/kexec-bzimage64.c b/arch/x86/kernel/kexec-bzimage64.c
index 57c2ecf43134..30f1fe92bb53 100644
--- a/arch/x86/kernel/kexec-bzimage64.c
+++ b/arch/x86/kernel/kexec-bzimage64.c
@@ -18,6 +18,7 @@
 #include <linux/mm.h>
 #include <linux/efi.h>
 #include <linux/verification.h>
+#include <linux/kvm_para.h>
 
 #include <asm/bootparam.h>
 #include <asm/setup.h>
@@ -263,6 +264,9 @@ static int bzImage64_probe(const char *buf, unsigned long len)
 {
 	int ret = -ENOEXEC;
 	struct setup_header *header;
+	struct kernel_info *info;
+	u32 setup_sects;
+	u32 kernel_start;
 
 	/* kernel should be at least two sectors long */
 	if (len < 2 * 512) {
@@ -281,7 +285,39 @@ static int bzImage64_probe(const char *buf, unsigned long len)
 		return ret;
 	}
 
-	if (header->version < 0x020C) {
+	if (IS_ENABLED(CONFIG_PARAVIRT_CR_PINNING) && kvm_paravirt_cr_pinning_enabled) {
+		if (header->version < 0x020F) {
+			pr_err("Must be at least protocol version 2.15\n");
+			return ret;
+		}
+
+		setup_sects = header->setup_sects;
+		if (!setup_sects)
+			setup_sects = 4;
+
+		kernel_start = (setup_sects + 1) << 9;
+
+		if (len < (sizeof(struct kernel_info) + kernel_start + header->kernel_info_offset)) {
+			pr_err("File is too short to contain kernel_info\n");
+			return ret;
+		}
+
+		info = (struct kernel_info *)(buf + kernel_start + header->kernel_info_offset);
+		if (memcmp((char *)&info->header, "LToP", 4) != 0) {
+			pr_err("Invalid kernel_info header\n");
+			return ret;
+		}
+
+		if (info->size < offsetof(struct kernel_info, pv_cr_pinning_magic)) {
+			pr_err("kernel_info lacks paravirtualized control register pinning magic\n");
+			return ret;
+		}
+
+		if (memcmp((char *)&info->pv_cr_pinning_magic, "PVCR", 4) != 0) {
+			pr_err("Paravirtualized control register pinning enabled but bzImage lacks support\n");
+			return ret;
+		}
+	} else if (header->version < 0x020C) {
 		pr_err("Must be at least protocol version 2.12\n");
 		return ret;
 	}
diff --git a/arch/x86/kernel/machine_kexec_64.c b/arch/x86/kernel/machine_kexec_64.c
index a29a44a98e5b..2c2a251eae00 100644
--- a/arch/x86/kernel/machine_kexec_64.c
+++ b/arch/x86/kernel/machine_kexec_64.c
@@ -24,6 +24,7 @@
 #include <asm/io_apic.h>
 #include <asm/debugreg.h>
 #include <asm/kexec-bzimage64.h>
+#include <asm/kvm_para.h>
 #include <asm/setup.h>
 #include <asm/set_memory.h>
 
@@ -587,6 +588,21 @@ void arch_kexec_unprotect_crashkres(void)
 	kexec_mark_crashkres(false);
 }
 
+int arch_kexec_load_check(unsigned long nr_segments,
+			  unsigned long flags)
+{
+	/*
+	 * Don't allow kexec_load syscall when paravirtualized control register
+	 * pinning is enabled. File based syscall can preform support checks,
+	 * load based syscall cannot. Ensure user hits support checks by
+	 * disallowing access to the load syscall.
+	 */
+	if (IS_ENABLED(CONFIG_PARAVIRT_CR_PINNING) && kvm_paravirt_cr_pinning_enabled)
+		return -EINVAL;
+
+	return 0;
+}
+
 /*
  * During a traditional boot under SME, SME will encrypt the kernel,
  * so the SME kexec kernel also needs to be un-encrypted in order to
-- 
2.21.0

